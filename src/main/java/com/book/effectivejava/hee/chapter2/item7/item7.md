# 아이템 7. 다 쓴 객체 참조를 해제하라
참조를 해제하는 방법: 다 쓴 객체에 null 을 할당하는 것.   
모든 경우에 다 쓴 객체 참조를 해제해야 하는 것은 아니지만 의외로 흔하게 사용되는 방법.

## 핵심정리
> * 어떤 객체에 대한 레퍼런스가 남아있다면 해당 객체는 가비지 컬렉션의 대상이 되지 않는다.  
> * 자기 메모리를 직접 관리하는 클래스라 메모리 누수에 주의해야 한다   
> * 예) 스택, 캐시, 리스너 또는 콜백   
> * 참조 객체는 null 처리하는 일은 예외적인 경우이며 가장 좋은 방법은 유효 범위 밖으로 밀어내는 것이다.

#### 메모리 누수가 발생하는 환경 3가지
1. Collection 과 같이 메모리를 직접 컨트롤 하는 객체 (Stack)
2. 캐시 - 캐시는 collection 의 pop 처럼 데이터를 빼내지 않고, 조회할 때마다 쌓아두기만 한다.   
> 캐시 역시 메모리 누수를 일으키는 주범이다. (p38)   
> 캐시 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap 을 사용해 캐시를 만든다.     
> WeakHashMap, WeakReference, Scheduled ThreadPoolExecutor .. 이건 어떤 개념?   

3. listener

-> 공통점 :  리스트, 배열, 셋, 맵 등 객체를 쌓아두는 공간이 존재한다.
객체가 계속 쌓여갈 때 정리를 잘 해주어야 메모리 누수 방지가 가능하다.
#### 메모리 누수를 정리하는 방법 3가지
1. 직접 null 을 넣어준다.   
   보통 공간에서 데이터를 빼 낼 때, 빠진 부분에 null 을 넣어주는 방법.   
   but, 캐시 처럼 데이터를 쌓기만 하고 빼내지 않을 때는 어떻게 해야할까?
2. 이럴 때 사용하는 게 WeakReference 를 이용한 WeakHashMap 이다. (p38 ~ p39)   
   WeakHashMap은 WeakReference 를 키로 가지는 해쉬맵이다.
   이 맵의 특징: 어떤 키가 더이상 참조가 안 되면, 그 키로 가지고 있는 value를 키와 함께 맵에서 제거(가비지 컬렉터가 제거함).
   Reference 의 종류: Strong, Soft, Weak, Pantom 이 있다.
